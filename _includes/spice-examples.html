{% include base_path %}

<div class="row">
  <div class="text-center" style="padding-bottom: 9px;">
    <button class="btn btn-primary btn-lg pull-left" onclick="step(-1)">Previous Example</button>
    <!--span id="image-title"></span-->
    <button class="btn btn-primary btn-lg pull-right" onclick="step(1)">Next Example</button>
  </div>
</div>
<div style="clear: both;">
  <div style="width: 60%; float: left;">
    <h4>Reference captions</h4>
    <div id="ref-panel"></div>
  </div>
  <div style="width: 40%; float: left;">
    <img id="caption-img" class="img-thumbnail" style="margin-top: 20px; max-height: 250px;">
  </div>
  <div style="width: 60%; float: left;">
    <h4>Reference scene graph</h4>
    <div id="reference"></div>
  </div>
  <div style="width: 40%; float: left;">
    <h4>Candidate caption & scene graph</h4>
    <div>
      <p id="candidate-caption"></p>
      <div id="candidate"></div>
      <p id="candidate-scores"></p>
    </div>
  </div>
  <div style="clear: both;"></div>
</div>
<script>
function renderSceneGraph(svg, tuples) {
  var nodes = {};
  var links = [];
  tuples.forEach(function(tuple_dict, index) {
    tuple = tuple_dict.tuple
    match_class = (tuple_dict.truth_value) ? ' highlighted' : '';
    if (tuple.length == 1){
      source = nodes[tuple[0]] || (nodes[tuple[0]] = {name: tuple[0], type: 'object'});
      source.type += match_class;
    } else if (tuple.length == 2) {
      source = nodes[tuple[0]] || (nodes[tuple[0]] = {name: tuple[0], type: 'object'});
      target = nodes[tuple[1]] || (nodes[tuple[1]] = {name: tuple[1], type: 'attribute'});
      source.type += match_class;
      target.type += match_class;
      links.push({source: source, target: target, type: 'standard'+match_class});
    } else if (tuple.length == 3) {
      source = nodes[tuple[0]] || (nodes[tuple[0]] = {name: tuple[0], type: 'object'});
      interim = nodes[tuple[1]] || (nodes[tuple[1]] = {name: tuple[1], type: 'relation'});
      target = nodes[tuple[2]] || (nodes[tuple[2]] = {name: tuple[2], type: 'object'});
      source.type += match_class;
      interim.type += match_class;
      target.type += match_class;
      links.push({source: nodes[tuple[0]], target: nodes[tuple[1]], type: 'standard'+match_class});
      links.push({source: nodes[tuple[1]], target: nodes[tuple[2]], type: 'standard'+match_class});
    }
  });

  links.forEach(function(d) {
    d.straight = 1;
    links.forEach(function(d1) {
      if ((d.source == d1.target) && (d1.source == d.target))
        d.straight = 0;
    });
  });

  var width = svg.style("width").replace("px", ""),
      height = svg.style("height").replace("px", "");

  var force = d3.layout.force()
      .nodes(d3.values(nodes))
      .links(links)
      .size([width, height])
      .linkDistance(50)
      .charge(-300)
      .on("tick", tick)
      .start();

  // Per-type markers, as they don't inherit styles.
  svg.append("defs").selectAll("marker")
      .data(["standard", "standard highlighted"])
    .enter().append("marker")
      .attr("id", function(d) { return d; })
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 15)
      .attr("refY", 0)
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
    .append("path")
      .attr("d", "M0,-5L10,0L0,5");

  // add the links and their arrows
  var path = svg.append("g").selectAll("path")
      .data(force.links())
    .enter().append("path")
      .attr("class", function(d) { return "link " + d.type; })
      .attr("marker-end", function(d) { return "url(#" + d.type + ")"; });

  // add the nodes
  var node = svg.append("g").selectAll("circle")
      .data(force.nodes())
    .enter().append("circle")
      .attr("r", 6)
      .attr("class", function(d) { return "sg " + d.type; })
      .call(force.drag);

  // add the text
  var text = svg.append("g").selectAll("text")
      .data(force.nodes())
    .enter().append("text")
      .attr("x", 8)
      //.attr("x", function() { console.log(this.getBoundingClientRect()); var offset=(this == 1)?8:-8; return offset; })
      .attr("y", ".31em")
      .text(function(d) { return d.name; });

  // Use elliptical arc path segments to doubly-encode directionality.
  function tick() {
    path.attr("d", linkArc);
    node.attr("transform", transform);
    text.attr("transform", transform);
  }

  function linkArc(d) {
    var dx = d.target.x - d.source.x,
        dy = d.target.y - d.source.y,
        dr = (d.straight == 0)?Math.sqrt(dx * dx + dy * dy):0;
    return "M" + d.source.x + "," + d.source.y +
        "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
  }

  function transform(d) {
    // Keep within bounds of svg
    var buffer = 7;
    x = Math.max(buffer, Math.min(width-buffer, d.x))
    y = Math.max(buffer, Math.min(height-buffer, d.y))
    return "translate(" + x + "," + y + ")";
  }
}

function visualizeit(item){
  // FIRST PANEL
  // Add title
  //d3.select("#image-title")
  //  .append("h4")
  //  .attr("class","removable")
  //  .text("Image: " + item.image_id);
  // Add image
  d3.select("#caption-img").attr("src", "http://mscoco.org/images/"+item.image_id);
  // reference captions
  item.reference_captions.forEach(function(caption) {
    p = d3.select("#ref-panel").append("p").attr("class","removable").text("\"" + caption + "\"");
  })

  // SECOND PANEL
  // reference sg
  var svg_ref = d3.select("#reference")
    .append("svg")
    .attr("class","removable")
    .attr("width", "100%")
    .attr("height", 350);
  renderSceneGraph(svg_ref, item.ref_tuples);

  // THIRD PANEL
  // candidate caption
  d3.select("#candidate-caption").text("\"" + item.test_caption[0] + "\"");
  // candidate scene graph
  var svg_ref = d3.select("#candidate")
    .append("svg")
    .attr("class","removable")
    .attr("width", "100%")
    .attr("height", 300);
  renderSceneGraph(svg_ref, item.test_tuples);
  // candidate scores
  d3.select("#candidate-scores").text("SPICE F-Score: " + item.scores.All.f + ", Pr: " + item.scores.All.pr + ", Re: " + item.scores.All.re);
}

item_index = 0;
d3.json("/images/coco_examples.json", function(error, json) {
  if (error) return console.warn(error);
  data = json;
  visualizeit(data[item_index]);
});

function step(distance){
  d3.selectAll(".removable").remove()
  item_index += distance;
  if (item_index < 0){
    item_index += data.length;
  }
  item_index %= data.length;
  visualizeit(data[item_index]);
};
</script>
